+++
title = "Protobufs are cool"
date = 2024-02-19T14:57:48-05:00
images = []
tags = ['tech', 'protobufs']
categories = []
draft = true
+++

For a couple years now, I've been leading a team at work that builds tools & infra around our usage of schemas. Stripe almost exclusively uses [Protocol Buffers](https://protobuf.dev) (protobufs for short) for our schemas, and I think the tech here is pretty cool!

# What's a protobuf?

First, let's walk through a practical example.

Let's say I have a Python program that needs to pass some data to a Ruby program. Let's say it's some information about a set of users.

I can use a protobuf to do this. First, I write a file describing the data:

```protobuf
// program_output.proto
syntax = "proto3";

package my.awesome.program;

// Some information about our users.
message User {
    string id = 1;
    string name = 2;
}

// The actual output format of our Python program.
message ProgramOutput {
    // A "repeated" field, which contains multiple users.
    repeated User users = 1;
}
```

This is a protobuf file. It follows the [Protocol Buffer file syntax](https://protobuf.dev/programming-guides/proto3/).

Next, I can use the protobuf compiler, `protoc`, to turn this file into a Python library. I run:

```
protoc --python_out=. program_output.proto
```

This outputs a Python file, `program_output_pb2.py`:
```python
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: program_output.proto
"""Generated protocol buffer code."""
# some generated code follows...
```

I can import this in my Python program, and use it to serialize data:
```python
// my_program.py
from program_output_pb2 import User, ProgramOutput
output = ProgramOutput(
  users=[
    User(id="1", name="me"),
    User(id="2", name="you"),
  ]
)

with open('output.bin', 'wb') as output_file:
  output_file.write(output.SerializeToString())
```

When I run this, I get some binary data in `output.bin`. I can then deserialize this in Ruby, by first generating a Ruby library:
```bash
protoc --ruby_out=. program_output.proto
cat program_output_pb.rb
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: program_output.proto
# more generated code follows...
```

Then using that in a Ruby program:
```ruby
# my_program.rb
require_relative 'program_output_pb.rb'

f = File.open('output.bin', 'rb')
o = My::Awesome::Program::ProgramOutput.decode(f.read)
puts o.users
```

When I run that, I get the input back, in nice Ruby objects:
```bash
ruby my_program.rb
<My::Awesome::Program::User: id: "1", name: "me">
<My::Awesome::Program::User: id: "2", name: "you">
```

That, in a nutshell, is what protobuf is -- it's a way to describe data & de/serialize it, and it lets you pass stuff between different programs and different languages in a way that makes sense.

- compatibility semantics

# What's cool about it?

- Human-readable
- It's insanely ambitious
- Right tool for the job
- Interfaces first

# Some not-so-cool things

- Controlled by Google
    - Semi-federated model
    - Changes are hard, esp. for some languages (Ruby)
    - Language bindings vary in quality
- Some things are weirdly/badly designed
    - `optional`
    - Editions
    - Extensions
    - Ruby language bindings